<calculator>
  <main class="calculator-container">
    <form class="calculator-container__inputform" onsubmit={ calculateTotals }>
      <label for="principle">Initial deposit</label>
      <input id="principle" ref="principle" type="number" onkeyup={ calculateTotals } value={ principle } placeholder="Principle amount">

      <label for="interest_rate">Interest rate (%)</label>
      <input id="interest_rate" ref="interest_rate" type="number" onkeyup={ calculateTotals } value={ interest_rate } placeholder="Interest rate (%)">

      <label for="years">Investment Time Span ({ years } years)</label>
      <input id="years" ref="years" type="range" min="1" max="50" oninput={ calculateTotals } value={ years }>

      <input type="submit" value="Calculate" ref="submitbutton">
    </form>

    <div class="calculator-container__chart-container">
      <canvas id="chart" width="200" height="100"></canvas>
    </div>

    <div class="calculator-container__totals-table-container">
      <h1>Results - Total: { overall_total }</h`>

      <table>
        <tr each={ total, i in totals }>
          <td>{ total[DS_OVERALL_TOTAL].year }</td><td>{ total[DS_OVERALL_TOTAL].value }</td>
        </tr>
      </table>
    </div>
  </main>

  <script>
    DS_PRINCIPLE = 0
    DS_INTEREST = 1
    DS_OVERALL_TOTAL = 2

    Array('years', 'principle', 'interest_rate').forEach(option => this[option] = opts[option])

    this.on('mount', function() {
      this.startYear = new Date().getFullYear()

      this.renderChart()
      this.update() // Necessary in mount handler to ensure results table gets rendered
    })

   /**
    * (Re-)render the chart when inputs have changed
    * @return {Void
    */
   this.on('updated', function() {
     this.renderChart()
   })

    /**
     * Calculate the totals
     * @return {Void}
     */
    calculateTotals (e) {
      if (e instanceof Event) e.preventDefault() // Prevent submitting form

      this.totals = Array.from({length: this.refs.years.value}, (_,i) => {
        let year = this.startYear + i
        let total = this.calculate(i + 1)
        let principle = this.refs.principle.value

        return [
          { year, value: this.formatValue(principle) },
          { year, value: this.formatValue(total - principle) },
          { year, value: this.formatValue(total) },
        ]
      })

      this.overall_total = this.totals[this.totals.length -1][DS_OVERALL_TOTAL].value
      this.years = this.refs.years.value
    }

    /**
     * Calculate the total amount for the requested number of years
     * Formula: P' = P(1 + r/n)^nt
     * @see https://en.wikipedia.org/wiki/Compound_interest#Mathematics_of_interest_rate_on_loans
     *
     * @return {Number}
     */
    calculate(years) {
      let interest = this.refs.interest_rate.value / 100 // decimal
      let compoundingFreqency = 1 // @TODO support additional regular deposits

      return this.refs.principle.value * Math.pow(1 + interest/compoundingFreqency, years * compoundingFreqency)
    }

    /**
     * Round a number to a given number of decimals
     * @TODO support multiple number formats (thousands separator, decimal separator)
     *
     * @return {Number}
     */
    formatValue (value, decimals = 2) {
      return Math.round(value * Math.pow(10, decimals)) / Math.pow(10, decimals)
    }

    /**
     * Initialize the chart.js object
     * @see http://www.chartjs.org/docs/latest/
     * @return {Void}
     */
    initChart () {
      this.chart = new Chart(document.getElementById('chart'), {
        type: 'bar',
        data: {
          datasets: [
            { label: 'Total principle', backgroundColor: 'orange' },
            { label: 'Total interest', backgroundColor: 'red' },
          ],
        },
        options: {
          scales: {
            xAxes: [{
              stacked: true,
            }],
            yAxes: [{
              stacked: true,
              ticks: {
                beginAtZero:true
              }
            }]
          },
          tooltips: {
            callbacks: {
              title: (tooltipItem, chart) => {
                let total = this.totals[tooltipItem[0].index][DS_OVERALL_TOTAL].value

                return `${tooltipItem[0].xLabel} (total: ${total})`
              },
            }
          },
        }
      })
    }

    /**
     * (Re-)render the chart.js chart
     * By pushing the data points onto the datasets, the chart animates nicely
     *
     * @return {Void}
     */
    renderChart () {
      if (!this.chart) this.initChart()
      this.clearChart()

      if (!this.totals) this.calculateTotals()

      this.totals.forEach(total => {
        this.chart.data.labels.push(total[DS_PRINCIPLE].year)
        this.chart.data.datasets[DS_PRINCIPLE].data.push(total[DS_PRINCIPLE].value)
        this.chart.data.datasets[DS_INTEREST].data.push(total[DS_INTEREST].value)
      })

      this.chart.update()
    }

    /**
     * Clear the chart.js chart
     * Necessary to ensure the chart animates correctly when new data is added to it
     *
     * @return {Void}
     */
    clearChart () {
      this.chart.data.labels = []
      this.chart.data.datasets[DS_PRINCIPLE].data = []
      this.chart.data.datasets[DS_INTEREST].data = []
    }
  </script>

  <style>
    .calculator-container {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      width: 70vw;
      margin: auto;
    }
    .calculator-container__inputform {
      flex-basis: 40%;
    }
    .calculator-container__inputform label {
      font-weight: bold;
    }

    .calculator-container__inputform label + input {
      display: block;
      margin-bottom: 1em;
    }

    .calculator-container__chart-container {
      flex-basis: 60%;
    }
  </style>
</calculator>
